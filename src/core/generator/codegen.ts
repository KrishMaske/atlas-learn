// =============================================================================
// Atlas — Code Generator
// =============================================================================
// Transforms the IR into real, usable TypeScript backend code.
// Target: Node.js + Express + TypeScript
// =============================================================================

import {
  NodeType,
  RestApiConfig,
  GraphqlApiConfig,
  RedisCacheConfig,
  SqlDatabaseConfig,
  NosqlDatabaseConfig,
  ObjectStorageConfig,
  SupabaseConfig,
  FirebaseConfig,
  GithubConfig,
  FunctionConfig,
} from '@/core/types';

import { IR, IRService, IRConnection } from './ir';

// -----------------------------------------------------------------------------
// Generated File
// -----------------------------------------------------------------------------

export interface GeneratedFile {
  path: string; // relative path within the project
  content: string;
  language: 'typescript' | 'json' | 'yaml' | 'markdown';
}

// -----------------------------------------------------------------------------
// Main Code Generator
// -----------------------------------------------------------------------------

export function generateCode(ir: IR): GeneratedFile[] {
  const files: GeneratedFile[] = [];

  // 1. package.json
  files.push(generatePackageJson(ir));

  // 2. tsconfig.json
  files.push(generateTsConfig(ir));

  // 3. Shared types
  files.push(generateSharedTypes(ir));

  // 4. Logger utility
  files.push(generateLogger());

  // 5. Per-service files
  for (const service of ir.services) {
    files.push(generateServiceFile(service, ir));
  }

  // 6. Main entry point (orchestrator)
  files.push(generateEntryPoint(ir));

  // 7. Docker Compose (if multiple services)
  if (ir.services.length > 1) {
    files.push(generateDockerCompose(ir));
  }

  // 8. README
  files.push(generateReadme(ir));

  return files;
}

// -----------------------------------------------------------------------------
// package.json
// -----------------------------------------------------------------------------

function generatePackageJson(ir: IR): GeneratedFile {
  const deps: Record<string, string> = {};
  const devDeps: Record<string, string> = {
    typescript: '^5.3.0',
    'ts-node': '^10.9.0',
    '@types/node': '^20.0.0',
    '@types/express': '^4.17.0',
    nodemon: '^3.0.0',
  };

  // Always need express
  deps['express'] = '^4.18.0';
  deps['cors'] = '^2.8.0';
  devDeps['@types/cors'] = '^2.8.0';

  // Add service-specific dependencies
  for (const svc of ir.services) {
    for (const pkg of svc.packages) {
      if (pkg.startsWith('@types/')) {
        devDeps[pkg] = '*';
      } else {
        deps[pkg] = getPackageVersion(pkg);
      }
    }
  }

  const pkg = {
    name: ir.projectName,
    version: '1.0.0',
    description: `Backend generated by Atlas — ${ir.services.length} services`,
    scripts: {
      dev: 'nodemon --exec ts-node src/index.ts',
      build: 'tsc',
      start: 'node dist/index.js',
    },
    dependencies: deps,
    devDependencies: devDeps,
  };

  return {
    path: 'package.json',
    content: JSON.stringify(pkg, null, 2),
    language: 'json',
  };
}

function getPackageVersion(pkg: string): string {
  const versions: Record<string, string> = {
    express: '^4.18.0',
    cors: '^2.8.0',
    '@apollo/server': '^4.9.0',
    graphql: '^16.8.0',
    ioredis: '^5.3.0',
    pg: '^8.11.0',
    '@prisma/client': '^5.0.0',
    mongodb: '^6.0.0',
    '@aws-sdk/client-s3': '^3.400.0',
    '@supabase/supabase-js': '^2.38.0',
    'firebase-admin': '^11.11.0',
    '@octokit/rest': '^20.0.0',
  };
  return versions[pkg] ?? '*';
}

// -----------------------------------------------------------------------------
// tsconfig.json
// -----------------------------------------------------------------------------

function generateTsConfig(_ir: IR): GeneratedFile {
  const config = {
    compilerOptions: {
      target: 'ES2020',
      module: 'commonjs',
      lib: ['ES2020'],
      outDir: './dist',
      rootDir: './src',
      strict: true,
      esModuleInterop: true,
      skipLibCheck: true,
      forceConsistentCasingInFileNames: true,
      resolveJsonModule: true,
      declaration: true,
    },
    include: ['src/**/*'],
    exclude: ['node_modules', 'dist'],
  };

  return {
    path: 'tsconfig.json',
    content: JSON.stringify(config, null, 2),
    language: 'json',
  };
}

// -----------------------------------------------------------------------------
// Shared Types
// -----------------------------------------------------------------------------

function generateSharedTypes(ir: IR): GeneratedFile {
  const lines: string[] = [
    '// =============================================================================',
    `// ${ir.projectName} — Shared Types (generated by Atlas)`,
    '// =============================================================================',
    '',
    'export interface ServiceRequest {',
    '  id: string;',
    '  timestamp: number;',
    '  payload: Record<string, unknown>;',
    '  headers?: Record<string, string>;',
    '}',
    '',
    'export interface ServiceResponse {',
    '  success: boolean;',
    '  data?: unknown;',
    '  error?: string;',
    '  latencyMs?: number;',
    '}',
    '',
    '// Service registry — maps service IDs to their URLs',
    'export const SERVICE_REGISTRY: Record<string, string> = {',
  ];

  for (const svc of ir.services) {
    lines.push(`  '${svc.slug}': 'http://localhost:${svc.port}',`);
  }

  lines.push('};');
  lines.push('');

  return {
    path: 'src/shared/types.ts',
    content: lines.join('\n'),
    language: 'typescript',
  };
}

// -----------------------------------------------------------------------------
// Logger
// -----------------------------------------------------------------------------

function generateLogger(): GeneratedFile {
  return {
    path: 'src/shared/logger.ts',
    content: `// =============================================================================
// Logger utility (generated by Atlas)
// =============================================================================

export function log(service: string, message: string, data?: unknown): void {
  const ts = new Date().toISOString();
  console.log(\`[\${ts}] [\${service}] \${message}\`, data ? JSON.stringify(data) : '');
}

export function error(service: string, message: string, err?: unknown): void {
  const ts = new Date().toISOString();
  console.error(\`[\${ts}] [\${service}] ERROR: \${message}\`, err);
}
`,
    language: 'typescript',
  };
}

// -----------------------------------------------------------------------------
// Per-Service File Generator (dispatches to type-specific generators)
// -----------------------------------------------------------------------------

function generateServiceFile(service: IRService, ir: IR): GeneratedFile {
  const code = generateServiceCode(service, ir);
  return {
    path: `src/services/${service.slug}.ts`,
    content: code,
    language: 'typescript',
  };
}

function generateServiceCode(svc: IRService, ir: IR): string {
  // Check for custom code override
  // Note: ContextConfig doesn't have customCode, but IR excludes Context nodes from services
  if ('customCode' in svc.config && svc.config.customCode) {
    return generateCustomServiceCode(svc, ir, svc.config.customCode);
  }

  switch (svc.nodeType) {
    case 'REST_API':
      return genRestApi(svc, ir);
    case 'GRAPHQL_API':
      return genGraphqlApi(svc, ir);
    case 'REDIS_CACHE':
      return genRedisCache(svc, ir);
    case 'SQL_DATABASE':
      return genSqlDatabase(svc, ir);
    case 'NOSQL_DATABASE':
      return genNosqlDatabase(svc, ir);
    case 'OBJECT_STORAGE':
      return genObjectStorage(svc, ir);
    case 'SUPABASE':
      return genSupabase(svc, ir);
    case 'FIREBASE':
      return genFirebase(svc, ir);
    case 'GITHUB':
      return genGithub(svc, ir);
    case 'FUNCTION':
      return genFunction(svc, ir);
    default:
      return genGenericService(svc, ir);
  }
}

// Helper to wrap custom code in standard service boilerplate
function generateCustomServiceCode(svc: IRService, ir: IR, customCode: string): string {
  return `${header(svc)}
import express from 'express';
import cors from 'cors';
import { log } from '../shared/logger';

const app = express();
app.use(cors());
app.use(express.json());

app.get('/health', (_req, res) => {
  res.json({ status: 'healthy', service: '${svc.slug}' });
});

app.all('*', async (req, res) => {
    if (req.path === '/health') return;

    log('${svc.slug}', \`Processing \${req.method} \${req.path}\`);
    try {
        const input = {
            method: req.method,
            path: req.path,
            body: req.body,
            query: req.query,
            headers: req.headers
        };
        
        const mockConsole = {
            log: (...args: any[]) => log('${svc.slug}', args.join(' ')),
            error: (...args: any[]) => log('${svc.slug}', 'ERROR:', args.join(' '))
        };

        const fn = new Function('input', 'console', \`
            return (async () => {
                ${customCode}
            })();
        \`);
        
        const result = await fn(input, mockConsole);
        res.json(result);

    } catch (err: any) {
        log('${svc.slug}', 'Execution failed', err);
        res.status(500).json({ error: err.message });
    }
});

app.listen(${svc.port}, () => {
  log('${svc.slug}', 'Custom Service listening on port ${svc.port}');
});

export default app;
`;
}

// Helper: generate downstream call code
function downstreamCalls(svc: IRService, ir: IR): string {
  if (svc.downstreamIds.length === 0) return '';

  const lines: string[] = ['', '// --- Downstream service calls ---'];
  for (const dsId of svc.downstreamIds) {
    const ds = ir.services.find((s) => s.id === dsId);
    if (!ds) continue;
    lines.push(`
async function call${capitalize(ds.slug)}(data: unknown): Promise<unknown> {
  const res = await fetch('http://localhost:${ds.port}/process', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  return res.json();
}`);
  }
  return lines.join('\n');
}

function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

function header(svc: IRService): string {
  return `// =============================================================================
// ${svc.name} — ${svc.nodeType} (generated by Atlas)
// Port: ${svc.port}
// =============================================================================
`;
}

// -----------------------------------------------------------------------------
// Node-type Specific Generators
// -----------------------------------------------------------------------------

function genRestApi(svc: IRService, ir: IR): string {
  const config = svc.config as RestApiConfig;
  const path = config.path || '/api/resource';
  const method = config.method?.toLowerCase() || 'get';

  return `${header(svc)}
import express from 'express';
import cors from 'cors';
import { log } from '../shared/logger';

const app = express();
app.use(cors());
app.use(express.json());

app.get('/health', (_req, res) => {
  res.json({ status: 'healthy', service: '${svc.slug}' });
});

// Main endpoint
app.${method}('${path}', async (req, res) => {
  log('${svc.slug}', \`\${req.method} ${path}\`);
  try {
    ${svc.downstreamIds.length > 0 ? `// Call downstream service(s)
    ${svc.downstreamIds.map((dsId) => {
    const ds = ir.services.find((s) => s.id === dsId);
    return ds ? `const ${ds.slug}Result = await fetch('http://localhost:${ds.port}/process', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(req.body || {}),
    }).then(r => r.json());` : '';
  }).join('\n    ')}
    res.json({ success: true, data: { ${svc.downstreamIds.map((dsId) => {
    const ds = ir.services.find((s) => s.id === dsId);
    return ds ? `${ds.slug}: ${ds.slug}Result` : '';
  }).filter(Boolean).join(', ')} } });` : `// No downstream services — return directly
    res.json({ success: true, data: { message: '${svc.name} processed request' } });`}
  } catch (err) {
    log('${svc.slug}', 'Error processing request', err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Generic process endpoint (called by upstream services)
app.post('/process', async (req, res) => {
  log('${svc.slug}', 'Processing upstream request');
  ${svc.downstreamIds.length > 0 ? `try {
    ${svc.downstreamIds.map((dsId) => {
    const ds = ir.services.find((s) => s.id === dsId);
    return ds ? `const result = await fetch('http://localhost:${ds.port}/process', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(req.body),
    }).then(r => r.json());
    res.json(result);` : '';
  }).join('\n    ')}
  } catch (err) {
    res.status(500).json({ error: 'Downstream call failed' });
  }` : `res.json({ success: true, data: req.body });`}
});

app.listen(${svc.port}, () => {
  log('${svc.slug}', '${svc.name} listening on port ${svc.port}');
});

export default app;
`;
}

function genGraphqlApi(svc: IRService, _ir: IR): string {
  const config = svc.config as GraphqlApiConfig;
  return `${header(svc)}
import { ApolloServer } from '@apollo/server';
import { startStandaloneServer } from '@apollo/server/standalone';
import { log } from '../shared/logger';

const typeDefs = \`#graphql
  type Query {
    hello: String
    health: HealthStatus
  }

  type HealthStatus {
    status: String
    service: String
  }
\`;

const resolvers = {
  Query: {
    hello: () => 'Hello from ${svc.name}',
    health: () => ({
      status: 'healthy',
      service: '${svc.slug}',
    }),
  },
};

async function startServer() {
  const server = new ApolloServer({
    typeDefs,
    resolvers,
    // Depth and complexity limits
    // maxDepth: ${config.maxDepth},
  });

  const { url } = await startStandaloneServer(server, {
    listen: { port: ${svc.port} },
  });

  log('${svc.slug}', \`GraphQL API ready at \${url}\`);
}

startServer().catch((err) => {
  log('${svc.slug}', 'Failed to start GraphQL server', err);
  process.exit(1);
});
`;
}

function genRedisCache(svc: IRService, _ir: IR): string {
  const config = svc.config as RedisCacheConfig;
  return `${header(svc)}
import express from 'express';
import Redis from 'ioredis';
import { log } from '../shared/logger';

const app = express();
app.use(express.json());

// In a real generation, we'd use environment variables or user-supplied connection strings
// For now, we simulate a mock or assume localhost
const redis = new Redis({
  lazyConnect: true, // Don't crash if Redis isn't running
});

app.get('/health', (_req, res) => {
  res.json({ status: 'healthy', service: '${svc.slug}' });
});

app.post('/cache/set', async (req, res) => {
  const { key, value } = req.body;
  await redis.set(key, value, 'EX', ${config.ttl});
  res.json({ success: true });
});

app.get('/cache/get/:key', async (req, res) => {
  const value = await redis.get(req.params.key);
  res.json({ value });
});

app.post('/process', async (req, res) => {
  // Passthrough or cache logic
  res.json({ message: 'Redis Cache Service' });
});

app.listen(${svc.port}, () => {
  log('${svc.slug}', '${svc.name} listening on port ${svc.port}');
});

export default app;
`;
}

function genSqlDatabase(svc: IRService, _ir: IR): string {
  const config = svc.config as SqlDatabaseConfig;
  return `${header(svc)}
import express from 'express';
import { log } from '../shared/logger';

// Example: Using Prisma or PG
// import { Client } from 'pg';

const app = express();
app.use(express.json());

// Config
// Engine: ${config.engine}
// Pool Size: ${config.poolSize}

app.get('/health', (_req, res) => {
  res.json({ status: 'healthy', service: '${svc.slug}', engine: '${config.engine}' });
});

// Mock query endpoint
app.post('/query', (req, res) => {
  const { sql } = req.body;
  log('${svc.slug}', \`Executing SQL: \${sql}\`);
  res.json({ rows: [], rowCount: 0, mock: true });
});

app.post('/process', (req, res) => {
  res.json({ message: 'SQL Database Service' });
});

app.listen(${svc.port}, () => {
  log('${svc.slug}', '${svc.name} listening on port ${svc.port}');
});

export default app;
`;
}

function genNosqlDatabase(svc: IRService, _ir: IR): string {
  const config = svc.config as NosqlDatabaseConfig;
  return `${header(svc)}
import express from 'express';
import { log } from '../shared/logger';

const app = express();
app.use(express.json());

// Config
// Engine: ${config.engine}

app.get('/health', (_req, res) => {
  res.json({ status: 'healthy', service: '${svc.slug}', engine: '${config.engine}' });
});

// Mock query endpoint
app.post('/document', (req, res) => {
  log('${svc.slug}', \`Processing document request\`);
  res.json({ success: true, mock: true });
});

app.post('/process', (req, res) => {
  res.json({ message: 'NoSQL Database Service' });
});

app.listen(${svc.port}, () => {
  log('${svc.slug}', '${svc.name} listening on port ${svc.port}');
});

export default app;
`;
}

function genObjectStorage(svc: IRService, _ir: IR): string {
  const config = svc.config as ObjectStorageConfig;
  return `${header(svc)}
import express from 'express';
import { log } from '../shared/logger';

const app = express();
app.use(express.json());

// Config
// Region: ${config.region}

app.get('/health', (_req, res) => {
  res.json({ status: 'healthy', service: '${svc.slug}' });
});

app.post('/upload', (req, res) => {
  log('${svc.slug}', \`File upload request\`);
  res.json({ success: true, url: 'https://example.com/file.png' });
});

app.post('/process', (req, res) => {
  res.json({ message: 'Object Storage Service' });
});

app.listen(${svc.port}, () => {
  log('${svc.slug}', '${svc.name} listening on port ${svc.port}');
});

export default app;
`;
}

function genSupabase(svc: IRService, _ir: IR): string {
  const config = svc.config as SupabaseConfig;
  return `${header(svc)}
import express from 'express';
import { createClient } from '@supabase/supabase-js';
import { log } from '../shared/logger';

const app = express();
app.use(express.json());

const SUPABASE_URL = process.env.SUPABASE_URL || '${config.url || "https://example.supabase.co"}';
const SUPABASE_KEY = process.env.SUPABASE_KEY || '${config.key || "your-anon-key"}';

const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

app.get('/health', (_req, res) => {
  res.json({ status: 'healthy', service: '${svc.slug}', features: ${JSON.stringify(config.features)} });
});

app.post('/process', async (req, res) => {
  // Example integration
  log('${svc.slug}', 'Processing Supabase request');
  res.json({ message: 'Supabase Integration Service' });
});

app.listen(${svc.port}, () => {
  log('${svc.slug}', '${svc.name} listening on port ${svc.port}');
});

export default app;
`;
}

function genFirebase(svc: IRService, _ir: IR): string {
  const config = svc.config as FirebaseConfig;
  return `${header(svc)}
import express from 'express';
import * as admin from 'firebase-admin';
import { log } from '../shared/logger';

const app = express();
app.use(express.json());

// Initialize Firebase Admin (requires credentials in environment)
if (!admin.apps.length) {
  // admin.initializeApp();
  console.log('Firebase Admin initialized (mock)');
}

app.get('/health', (_req, res) => {
  res.json({ status: 'healthy', service: '${svc.slug}', features: ${JSON.stringify(config.features)} });
});

app.post('/process', async (req, res) => {
  log('${svc.slug}', 'Processing Firebase request');
  res.json({ message: 'Firebase Integration Service' });
});

app.listen(${svc.port}, () => {
  log('${svc.slug}', '${svc.name} listening on port ${svc.port}');
});

export default app;
`;
}

function genGithub(svc: IRService, _ir: IR): string {
  const config = svc.config as GithubConfig;
  return `${header(svc)}
import express from 'express';
import { Octokit } from '@octokit/rest';
import { log } from '../shared/logger';

const app = express();
app.use(express.json());

const octokit = new Octokit({
  auth: process.env.GITHUB_TOKEN,
});

app.get('/health', (_req, res) => {
  res.json({ status: 'healthy', service: '${svc.slug}', repo: '${config.repo}' });
});

// Webhook endpoint
app.post('/webhook', (req, res) => {
  log('${svc.slug}', 'Received GitHub webhook');
  res.json({ received: true });
});

app.post('/process', async (req, res) => {
  log('${svc.slug}', 'Processing GitHub interaction');
  res.json({ message: 'GitHub Integration Service' });
});

app.listen(${svc.port}, () => {
  log('${svc.slug}', '${svc.name} listening on port ${svc.port}');
});

export default app;
`;
}

function genFunction(svc: IRService, _ir: IR): string {
  const config = svc.config as FunctionConfig;
  // This is similar to Custom Logic but with more specific "Serverless Function" semantics
  return `${header(svc)}
import express from 'express';
import cors from 'cors';
import { log } from '../shared/logger';

const app = express();
app.use(cors());
app.use(express.json());

app.get('/health', (_req, res) => {
  res.json({ status: 'healthy', service: '${svc.slug}', language: '${config.language}' });
});

app.all('*', async (req, res) => {
    if (req.path === '/health') return;

    log('${svc.slug}', \`Executing \${req.method} \${req.path}\`);
    try {
        const context = {
            log: (msg: string) => log('${svc.slug}', msg),
        };

        const input = req.body;
        
        // Execute user code
        // wrapped in an async function
        const fn = new Function('input', 'context', \`
            return (async () => {
                ${config.code || '// No code provided'}
            })();
        \`);
        
        const result = await fn(input, context);
        res.json(result);

    } catch (err: any) {
        log('${svc.slug}', 'Function execution failed', err);
        res.status(500).json({ error: err.message });
    }
});

app.listen(${svc.port}, () => {
  log('${svc.slug}', '${svc.name} listening on port ${svc.port}');
});

export default app;
`;
}

function genGenericService(svc: IRService, _ir: IR): string {
  return `${header(svc)}
import express from 'express';
import cors from 'cors';
import { log } from '../shared/logger';

const app = express();
app.use(cors());
app.use(express.json());

app.get('/health', (_req, res) => {
  res.json({ status: 'healthy', service: '${svc.slug}' });
});

app.all('*', (req, res) => {
  log('${svc.slug}', \`Received \${req.method} \${req.path}\`);
  res.json({ message: 'Service operational', nodeType: '${svc.nodeType}' });
});

app.listen(${svc.port}, () => {
  log('${svc.slug}', '${svc.name} listening on port ${svc.port}');
});

export default app;
`;
}

function generateEntryPoint(ir: IR): GeneratedFile {
  const lines: string[] = [
    '// =============================================================================',
    `// ${ir.projectName} — Main Orchestrator`,
    '// =============================================================================',
    '',
    `console.log('Starting ${ir.projectName} backend...');`,
    '',
    `// In a real microservices deployment, each service would be a separate container/process.`,
    `// For this local dev setup, we are running them as independent processes via nodemon,`,
    `// or you could spawn them here.`,
    '',
    `// See package.json scripts or docker-compose.yml`,
  ];

  return {
    path: 'src/index.ts',
    content: lines.join('\n'),
    language: 'typescript',
  };
}

function generateDockerCompose(ir: IR): GeneratedFile {
  let content = `version: '3.8'
services:
`;

  for (const svc of ir.services) {
    content += `  ${svc.slug}:
    build: .
    command: npx ts-node src/services/${svc.slug}.ts
    ports:
      - "${svc.port}:${svc.port}"
    environment:
      - PORT=${svc.port}
      - NODE_ENV=development
    volumes:
      - .:/app
`;
  }

  return {
    path: 'docker-compose.yml',
    content,
    language: 'yaml',
  };
}

function generateReadme(ir: IR): GeneratedFile {
  return {
    path: 'README.md',
    content: `# ${ir.projectName}

Generated by Atlas.

## Services

${ir.services.map(s => `- **${s.name}** (${s.nodeType}) running on port ${s.port}`).join('\n')}

## Getting Started

1. Install dependencies:
   \`\`\`bash
   npm install
   \`\`\`

2. Run in development mode:
   \`\`\`bash
   npm run dev
   \`\`\`
`,
    language: 'markdown',
  };
}
