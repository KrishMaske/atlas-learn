'use client';

import { useMemo, useCallback, useState } from 'react';
import { useGraphStore } from '@/core/graph/graphStore';
import { compileGraphToIR } from '@/core/generator/ir';
import { generateCode, GeneratedFile } from '@/core/generator/codegen';

// =============================================================================
// ExportDialog — downloads generated project as individual files or a zip
// =============================================================================

async function downloadZip(files: GeneratedFile[], projectName: string) {
  // Build a simple tar-like concatenation via Blob + content script
  // Since we can't import JSZip without adding deps, we use a self-contained
  // approach: create an in-memory zip with the DecompressionStream polyfill
  // pattern. For simplicity, we download each file in a folder structure.
  // Actually, let's use a simple approach: download a shell script that
  // recreates the project, or use the built-in Blob zip approach.

  // Simple approach: create a single concatenated file with clear separators
  // that the user can split, OR just trigger individual downloads.

  // Best UX: create individual files via anchor clicks
  for (const file of files) {
    const blob = new Blob([file.content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    // Flatten path for download (browsers don't support nested paths)
    a.download = file.path.replace(/\//g, '__');
    a.click();
    URL.revokeObjectURL(url);
    // Small delay to avoid browser blocking multiple downloads
    await new Promise((r) => setTimeout(r, 100));
  }

  // Also download a setup script that restructures them
  const script = `#!/bin/bash
# ${projectName} — Generated by Atlas
# Run this script in an empty directory to set up the project structure.

set -e

${files.map((f) => {
  const dir = f.path.includes('/') ? f.path.substring(0, f.path.lastIndexOf('/')) : '';
  return dir ? `mkdir -p "${dir}"` : '';
}).filter(Boolean).filter((v, i, a) => a.indexOf(v) === i).join('\n')}

${files.map((f) => {
  const flat = f.path.replace(/\//g, '__');
  return `[ -f "${flat}" ] && mv "${flat}" "${f.path}"`;
}).join('\n')}

echo "Project structure created! Run: npm install && npm run dev"
`;

  const blob = new Blob([script], { type: 'text/x-shellscript' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `setup-${projectName}.sh`;
  a.click();
  URL.revokeObjectURL(url);
}

async function downloadSingleBundle(files: GeneratedFile[], projectName: string) {
  // Download as a single Markdown-style bundle that's easy to split
  const bundle = `# ${projectName} — Generated by Atlas
# ============================================
# This file contains all generated source files.
# Each file is separated by a header comment.
# Use the companion setup script or manually split.
# ============================================

${files.map((f) => `${'='.repeat(60)}
FILE: ${f.path}
${'='.repeat(60)}
${f.content}
`).join('\n')}`;

  const blob = new Blob([bundle], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${projectName}-bundle.txt`;
  a.click();
  URL.revokeObjectURL(url);
}

export default function ExportDialog({
  open,
  onClose,
}: {
  open: boolean;
  onClose: () => void;
}) {
  const { nodes, edges } = useGraphStore();
  const [projectName, setProjectName] = useState('my-backend');
  const [exporting, setExporting] = useState(false);

  const generated = useMemo(() => {
    if (nodes.length === 0) return [];
    try {
      const graph = { nodes, edges, selectedNodeId: null };
      const ir = compileGraphToIR(graph, projectName);
      return generateCode(ir);
    } catch {
      return [];
    }
  }, [nodes, edges, projectName]);

  const handleExportBundle = useCallback(async () => {
    setExporting(true);
    await downloadSingleBundle(generated, projectName);
    setExporting(false);
  }, [generated, projectName]);

  const handleExportFiles = useCallback(async () => {
    setExporting(true);
    await downloadZip(generated, projectName);
    setExporting(false);
  }, [generated, projectName]);

  if (!open) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm">
      <div className="bg-slate-800 rounded-2xl border border-slate-700 shadow-2xl w-full max-w-lg mx-4">
        {/* Header */}
        <div className="flex items-center justify-between px-6 py-4 border-b border-slate-700">
          <h2 className="text-white font-semibold">Export Project</h2>
          <button
            onClick={onClose}
            className="text-slate-400 hover:text-white transition-colors text-lg"
          >
            ✕
          </button>
        </div>

        {/* Body */}
        <div className="px-6 py-5 space-y-4">
          {/* Project Name */}
          <div>
            <label className="text-slate-400 text-sm block mb-1">
              Project Name
            </label>
            <input
              type="text"
              value={projectName}
              onChange={(e) =>
                setProjectName(e.target.value.replace(/[^a-z0-9-]/g, ''))
              }
              className="w-full bg-slate-700 text-white rounded-lg px-3 py-2 text-sm border border-slate-600 font-mono"
              placeholder="my-backend"
            />
          </div>

          {/* Summary */}
          <div className="bg-slate-900/60 rounded-lg p-4 text-sm">
            <div className="flex items-center justify-between text-slate-400 mb-2">
              <span>Files to generate</span>
              <span className="font-mono text-white">{generated.length}</span>
            </div>
            <div className="flex items-center justify-between text-slate-400 mb-2">
              <span>Total lines</span>
              <span className="font-mono text-white">
                {generated.reduce(
                  (s, f) => s + f.content.split('\n').length,
                  0
                )}
              </span>
            </div>
            <div className="text-xs text-slate-500 mt-3">
              Includes: package.json, tsconfig.json, Docker Compose,
              service files, shared utilities, and README
            </div>
          </div>

          {generated.length === 0 && (
            <p className="text-amber-400 text-sm">
              No service nodes found. Add at least one non-client node to
              generate code.
            </p>
          )}
        </div>

        {/* Actions */}
        <div className="px-6 py-4 border-t border-slate-700 flex gap-3">
          <button
            onClick={handleExportBundle}
            disabled={generated.length === 0 || exporting}
            className="flex-1 py-2.5 bg-blue-600 hover:bg-blue-500 disabled:opacity-50 text-white rounded-lg text-sm font-medium transition-colors"
          >
            {exporting ? 'Exporting…' : 'Download Bundle'}
          </button>
          <button
            onClick={handleExportFiles}
            disabled={generated.length === 0 || exporting}
            className="flex-1 py-2.5 bg-slate-700 hover:bg-slate-600 disabled:opacity-50 text-white rounded-lg text-sm font-medium transition-colors"
          >
            {exporting ? 'Exporting…' : 'Download Files'}
          </button>
        </div>
      </div>
    </div>
  );
}
